is_mac=0; [[ "$OSTYPE" == "darwin"* ]] && is_mac=1

export CLICOLOR=1
export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
export EDITOR=nvim
alias ls="ls --color=always"
alias ll="ls -l --group-directories-first"
alias llh="ls -lh --group-directories-first"
alias t4="ping 4.2.2.4 -i 0.3"
alias grep='grep --color -i'

# History
shopt -s histappend
export HISTSIZE=100000
export HISTFILESIZE=-1

# Homebrew (Intel and M1)
#
# This will define HOMEBREW_PREFIX, HOMEBREW_CELLAR and other env variables. It
# will also add Homebrew's bin and sbin directories to the PATH We create an
# env file one and source it subsequent bash startups. The reason is that
# `brew` is quite slow and calling it every time would make Bash startup slow.
_brew_env_file="$HOME/.brew_env"
__make_brew_envs_file() {
    # If a proper file already exists, nothing to do.
    if grep -Fq HOMEBREW_PREFIX "$_brew_env_file" 2>/dev/null ; then
        return
    fi

    echo "Creating '$_brew_env_file' file for the first time."

    echo "# Auto-generated by .bashrc script" > $_brew_env_file
    echo >> $_brew_env_file

    if [[ -x "$(command -v /opt/homebrew/bin/brew)" ]]; then
        /opt/homebrew/bin/brew shellenv >> $_brew_env_file
    elif [[ -x "$(command -v /usr/local/bin/brew)" ]]; then
        /usr/local/bin/brew shellenv >> $_brew_env_file
    fi
}

__make_brew_envs_file && source $_brew_env_file

export GOPATH=$HOME/go
export GOBIN="$HOME/go/bin"

export PATH="$HOME/.local/bin:$PATH"
export PATH="$HOME/dotfiles/bash/scripts:$PATH"
export PATH="$HOME/.cargo/bin:$PATH"
export PATH="$GOBIN:$PATH"

if [ $is_mac = 1 ]; then
    export PATH="$HOMEBREW_PREFIX/opt/coreutils/libexec/gnubin:$PATH"
    export PATH="$HOMEBREW_PREFIX/opt/make/libexec/gnubin:$PATH"
    export PATH="$HOMEBREW_PREFIX/opt/gnu-sed/libexec/gnubin:$PATH"
    export PATH="$HOMEBREW_PREFIX/opt/grep/libexec/gnubin:$PATH"
    export PATH="$HOMEBREW_PREFIX/opt/openssl@3/bin:$PATH"
    export PATH="$HOMEBREW_PREFIX/opt/libpq/bin:$PATH"
    export PATH="$HOMEBREW_PREFIX/opt/mysql-client/bin:$PATH"
    export PATH="$HOMEBREW_PREFIX/opt/sqlite/bin:$PATH"
fi

start_t=$(date +%s.%N)

export RIPGREP_CONFIG_PATH=$HOME/.ripgreprc

# pyenv (on Linux installs)
export PYENV_ROOT="$HOME/.pyenv"
export PATH="$PYENV_ROOT/bin:$PATH"

if [ $is_mac = 1 ]; then
    [[ -r "$HOMEBREW_PREFIX/etc/profile.d/bash_completion.sh" ]] && . "$HOMEBREW_PREFIX/etc/profile.d/bash_completion.sh"
elif [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
fi

mkcd () {
    mkdir -p -- "$1" && cd -P -- "$1"
}

if [ $is_mac = 1 ]; then
    # Make sure pyenv creates the dynlib files when installs python
    export PYTHON_CONFIGURE_OPTS="--enable-framework"

    # Disable Homebrew auto update
    export HOMEBREW_NO_AUTO_UPDATE=1
fi

# direnv hook
eval "$(direnv hook bash)"

# Activate mise
export MISE_GO_SET_GOBIN=0
eval "$(mise activate bash)"

# Make fzf use gitignore
export FZF_DEFAULT_COMMAND='rg --files --hidden --follow'

# fzf completion
[[ -s "$HOME/.fzf.bash" ]] && source "$HOME/.fzf.bash"

# bun
export BUN_INSTALL="$HOME/.bun"
export PATH=$BUN_INSTALL/bin:$PATH

# Prevent Ctrl-D to exit the shell. This helps with accidentally exiting tmux.
# Ref: https://superuser.com/a/479614/161459
# Note: Disabled for now
export IGNOREEOF=0

# Use `exa` if available
if [[ -x "$(command -v eza)" ]]
then
    alias ls=eza
    alias ll="eza -l --group-directories-first --bytes"
fi
#
# Use `startship` if available
if [[ -x "$(command -v starship)" ]]
then
    eval "$(starship init bash)"
fi

# Immediately append commands to history
# See https://askubuntu.com/a/115625/184857
# export PROMPT_COMMAND="history -a; history -c; history -r; $PROMPT_COMMAND"

# Haskell
[ -f "$HOME/.ghcup/env" ] && source "$HOME/.ghcup/env" # ghcup-env

# MacTex
if [ $is_mac = 1 ]; then
    export PATH="/Library/TeX/texbin:$PATH"
fi

kitty-reload() {
    kill -SIGUSR1 $(pgrep -a kitty)
}

# I often mistype 'cd SomeDirectory' as 'c dSomeDirectory'.
# This function helps with that by removing the leading 'd' and running cd. :D 
function c {
    directory="$*"
    firstchar=${directory:0:1}
    if [ "$firstchar" != "d" ]; then 
      echo "First character isn't 'd'. Won't do anything."
      return
    fi

    directory="${directory:1}"
    echo "Seems you were trying to cd into '$directory'. Let me help..."
    cd "$directory" || return
}


# Load the local bashrc. 
# NOTE: keep line at the end of this file!
[[ -s "$HOME/.bashrc_local" ]] && source "$HOME/.bashrc_local"

# For debugging purposes
function __show_elapsed_time {
    local end_t diff_t
    end_t=$(date +%s.%N)
    diff_t=$(echo "($end_t - $start_t) * 1000 / 1" | bc)

    local RED GREEN RESET
    RED=$(tput setaf 1)
    GREEN=$(tput setaf 2)
    RESET=$(tput sgr0)

    local color;

    if [[ $diff_t -ge 200 ]]; then 
        color=$RED
    else
        color=$GREEN
    fi

    echo "Bash loaded in ${color}$diff_t ms${RESET}"
} && __show_elapsed_time && unset -f __show_elapsed_time

