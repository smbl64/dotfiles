# Load the bash prompt
source ~/.bash_prompt

is_mac=0; [ "$(uname -s)" = "Darwin" ] && is_mac=1

# --------------------------------------------------------
# Path and other exports
# --------------------------------------------------------

# Homebrew (Intel and M1)
# This will also add Homebrew's bin and sbin directories to the PATH
if [ -x "$(command -v /opt/homebrew/bin/brew)" ]
then
    eval $(/opt/homebrew/bin/brew shellenv)
elif [ -x "$(command -v /usr/local/bin/brew)" ]
then
    eval $(/usr/local/bin/brew shellenv)
fi

export GOPATH=$HOME/go

export PATH="$HOME/.local/bin:$PATH"

export PATH="$HOME/dotfiles/bash/scripts:$PATH"

if [ $is_mac = 1 ]; then
    # GNU core utils
    export PATH="$(brew --prefix)/opt/coreutils/libexec/gnubin:$PATH"
    export PATH="$(brew --prefix)/opt/make/libexec/gnubin:$PATH"
    export PATH="$(brew --prefix)/opt/gnu-sed/libexec/gnubin:$PATH"
    export PATH="$(brew --prefix)/opt/grep/libexec/gnubin:$PATH"
    export PATH="$(brew --prefix)/opt/openssl@3/bin:$PATH"
fi

if [ $is_mac = 1 ]; then
    export JAVA_HOME=$(/usr/libexec/java_home 2> /dev/null)
else
    # Using sed, replace 'bin/java' with an empty string
    export JAVA_HOME=$(readlink -f /usr/bin/java | sed "s:bin/java::")
fi

if [ $is_mac = 1 ]; then
    # psql
    export PATH="$(brew --prefix)/opt/libpq/bin:$PATH"

    # mysql client
    export PATH="$(brew --prefix)/opt/mysql-client/bin:$PATH"

    # poetry
    export PATH="$HOME/.poetry/bin:$PATH"
fi

# Rust cargo
export PATH="$HOME/.cargo/bin:$PATH"

# Go
export PATH=$PATH:$GOPATH/bin

export CLICOLOR=1
export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
export EDITOR="vim"

export RIPGREP_CONFIG_PATH=~/.ripgreprc

# pyenv (on Linux installs)
export PYENV_ROOT="$HOME/.pyenv"
export PATH="$PYENV_ROOT/bin:$PATH"

# --------------------------------------------------------
# Aliases 
# --------------------------------------------------------
alias ls="ls --color=always"
alias ll="ls -l --group-directories-first"
alias llh="ls -lh --group-directories-first"
alias t4="ping 4.2.2.4 -i 0.3"
alias grep='grep --color -i'
alias k=kubectl

mkcd () {
    mkdir -p -- "$1" && cd -P -- "$1"
}

__check_bash_completion_symlink() {
    # By default, bash-completion@2 package loads completions in this folder
    # eagerly: $(brew --prefix)/etc/bash_completion.d
    #
    # This will slow down startup time of Bash. To hack our way around it, we
    # will create a symlink to that folder and ask bash-completion@2 to loads
    # scripts in this symlink lazily.
    #
    # We will create a symlink "$(brew --prefix)/etc/bash-completion/completions" that
    # points to "$(brew --prefix)/etc/bash_completion.d".
    #
    # Note:
    # Remember to install the HEAD version of bash-completion@2, otherwise it
    # will not process multiple directories in "BASH_COMPLETION_USER_DIR".
    # (Use brew install --HEAD ...)

    # Create the symlink
    mkdir -p  "$(brew --prefix)/etc/bash-completion"
    ln -sf "$(brew --prefix)/etc/bash_completion.d" "$(brew --prefix)/etc/bash-completion/completions"

    # Directories for lazy-loading
    export BASH_COMPLETION_USER_DIR="$(brew --prefix)/etc/bash-completion:$HOME/.local/share/bash-completion"

    # Disable the eagerly-loaded completion scripts
    export BASH_COMPLETION_COMPAT_DIR="/blackhole!"
}

# --------------------------------------------------------
# Bash completion (for Bash 4+ and bash-completion@2
# --------------------------------------------------------
if [ $is_mac = 1 ]; then
    __check_bash_completion_symlink

    [[ -r "$(brew --prefix)/etc/profile.d/bash_completion.sh" ]] && . "$(brew --prefix)/etc/profile.d/bash_completion.sh"
elif [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
fi

# --------------------------------------------------------
# Other stuff
# --------------------------------------------------------
if [ $is_mac = 1 ]; then
    # Make sure pyenv creates the dynlib files when installs python
    export PYTHON_CONFIGURE_OPTS="--enable-framework"
fi

# For pyenv
#eval "$(pyenv init --path)"

# For pyenv-virtualenv
#eval "$(pyenv virtualenv-init -)"


if [ $is_mac = 1 ]; then
    # Fix pyenv macOS bug
    # https://github.com/pyenv/pyenv/issues/1219#issuecomment-482821959
    export CFLAGS="-I$(xcrun --show-sdk-path)/usr/include"

    # Disable Homebrew auto update
    export HOMEBREW_NO_AUTO_UPDATE=1
fi


# direnv hook
eval "$(direnv hook bash)"

# Make fzf use gitignore
export FZF_DEFAULT_COMMAND='rg --files --hidden --follow'
# alternative: export FZF_DEFAULT_COMMAND='ag -g ""'

# fzf completion
[ -f ~/.fzf.bash ] && source ~/.fzf.bash

# kubectl completion
if [ -x "$(command -v kubectl)" ]; then
    source <(kubectl completion bash)
    # Assuming 'k' is aliased to kubectl as well
    source <(kubectl completion bash | sed s/kubectl/k/g)
fi

#THIS MUST BE AT THE END OF THE FILE FOR SDKMAN TO WORK!!!
export SDKMAN_DIR="$HOME/.sdkman"
[[ -s "$HOME/.sdkman/bin/sdkman-init.sh" ]] && source "$HOME/.sdkman/bin/sdkman-init.sh"

# Load the local bashrc. 
# NOTE: keep line at the end of this file!
test -f ~/.bashrc_local && source ~/.bashrc_local
