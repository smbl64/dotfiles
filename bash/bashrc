is_mac=0; [[ "$OSTYPE" == "darwin"* ]] && is_mac=1

export CLICOLOR=1
export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
export EDITOR=nvim
alias ls="ls --color=always"
alias ll="ls -l --group-directories-first"
alias llh="ls -lh --group-directories-first"
alias t4="ping 4.2.2.4 -i 0.3"
alias grep='grep --color -i'

# Homebrew (Intel and M1)
#
# This will define HOMEBREW_PREFIX, HOMEBREW_CELLAR and other env variables. It
# will also add Homebrew's bin and sbin directories to the PATH We create an
# env file one and source it subsequent bash startups. The reason is that
# `brew` is quite slow and calling it every time would make Bash startup slow.
_brew_env_file="$HOME/.brew_env"
__make_brew_envs_file() {
    # If a proper file already exists, nothing to do.
    if grep -Fq HOMEBREW_PREFIX "$_brew_env_file" 2>/dev/null ; then
        return
    fi

    echo "Creating '$_brew_env_file' file for the first time."

    echo "# Auto-generated by .bashrc script" > $_brew_env_file
    echo >> $_brew_env_file

    if [[ -x "$(command -v /opt/homebrew/bin/brew)" ]]; then
        /opt/homebrew/bin/brew shellenv >> $_brew_env_file
    elif [[ -x "$(command -v /usr/local/bin/brew)" ]]; then
        /usr/local/bin/brew shellenv >> $_brew_env_file
    fi
}

__make_brew_envs_file && source $_brew_env_file

export GOPATH=$HOME/go
export PATH="$HOME/.local/bin:$PATH"
export PATH="$HOME/dotfiles/bash/scripts:$PATH"
export PATH="$HOME/.cargo/bin:$PATH"
export PATH="$GOPATH/bin:$PATH"

if [ $is_mac = 1 ]; then
    export PATH="$HOMEBREW_PREFIX/opt/coreutils/libexec/gnubin:$PATH"
    export PATH="$HOMEBREW_PREFIX/opt/make/libexec/gnubin:$PATH"
    export PATH="$HOMEBREW_PREFIX/opt/gnu-sed/libexec/gnubin:$PATH"
    export PATH="$HOMEBREW_PREFIX/opt/grep/libexec/gnubin:$PATH"
    export PATH="$HOMEBREW_PREFIX/opt/openssl@3/bin:$PATH"
    export PATH="$HOMEBREW_PREFIX/opt/libpq/bin:$PATH"
    export PATH="$HOMEBREW_PREFIX/opt/mysql-client/bin:$PATH"
    export PATH="$HOMEBREW_PREFIX/opt/sqlite/bin:$PATH"

    export PATH="$HOME/.poetry/bin:$PATH"
fi

start_t=$(echo $(date +%s.%N))

export RIPGREP_CONFIG_PATH=$HOME/.ripgreprc

# pyenv (on Linux installs)
export PYENV_ROOT="$HOME/.pyenv"
export PATH="$PYENV_ROOT/bin:$PATH"

# --------------------------------------------------------
# Bash completion (for Bash 4+ and bash-completion@2
# --------------------------------------------------------
__check_bash_completion_symlink() {
    # By default, bash-completion@2 package loads completions in this folder
    # eagerly: $(brew --prefix)/etc/bash_completion.d
    #
    # This will slow down startup time of Bash. To hack our way around it, we
    # will create a symlink to that folder and ask bash-completion@2 to loads
    # scripts in this symlink lazily.
    #
    # We will create a symlink "$(brew --prefix)/etc/bash-completion/completions" that
    # points to "$(brew --prefix)/etc/bash_completion.d".
    #
    # Note:
    # Remember to install the HEAD version of bash-completion@2, otherwise it
    # will not process multiple directories in "BASH_COMPLETION_USER_DIR".
    # (Use brew install --HEAD ...)

    # Create the symlink
    mkdir -p "$HOMEBREW_PREFIX/etc/bash-completion"
    ln -sf "$HOMEBREW_PREFIX/etc/bash_completion.d" "$HOMEBREW_PREFIX/etc/bash-completion/completions"

    # Directories for lazy-loading
    export BASH_COMPLETION_USER_DIR="$HOMEBREW_PREFIX/etc/bash-completion:$HOME/.local/share/bash-completion"

    # Disable the eagerly-loaded completion scripts
    export BASH_COMPLETION_COMPAT_DIR="/blackhole!"
}

if [ $is_mac = 1 ]; then
    __check_bash_completion_symlink

    [[ -r "$HOMEBREW_PREFIX/etc/profile.d/bash_completion.sh" ]] && . "$HOMEBREW_PREFIX/etc/profile.d/bash_completion.sh"
elif [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
fi

mkcd () {
    mkdir -p -- "$1" && cd -P -- "$1"
}

if [ $is_mac = 1 ]; then
    # Make sure pyenv creates the dynlib files when installs python
    export PYTHON_CONFIGURE_OPTS="--enable-framework"

    # Fix pyenv macOS bug
    # https://github.com/pyenv/pyenv/issues/1219#issuecomment-482821959
    export CFLAGS="-I$(xcrun --show-sdk-path)/usr/include"

    # Disable Homebrew auto update
    export HOMEBREW_NO_AUTO_UPDATE=1
fi

# direnv hook
eval "$(direnv hook bash)"

# Make fzf use gitignore
export FZF_DEFAULT_COMMAND='rg --files --hidden --follow'

# fzf completion
[[ -s "$HOME/.fzf.bash" ]] && source "$HOME/.fzf.bash"

# Prevent Ctrl-D to exit the shell. This helps with accidentally exiting tmux.
# Ref: https://superuser.com/a/479614/161459
# Note: Disabled for now
export IGNOREEOF=0

export SDKMAN_DIR="$HOME/.sdkman"
[[ -s "$HOME/.sdkman/bin/sdkman-init.sh" ]] && source "$HOME/.sdkman/bin/sdkman-init.sh"

# Use `exa` if available
if [[ -x "$(command -v exa)" ]]
then
    alias ls=exa
    alias ll="exa -l --group-directories-first --bytes"
fi
#
# Use `startship` if available
if [[ -x "$(command -v exa)" ]]
then
    eval "$(starship init bash)"
fi

# Load the local bashrc. 
# NOTE: keep line at the end of this file!
[[ -s "$HOME/.bashrc_local" ]] && source "$HOME/.bashrc_local"


# For debugging purposes
function __show_elapsed_time {
    local end_t=$(echo $(date +%s.%N))
    local diff_t=$(echo "($end_t - $start_t) * 1000 / 1" | bc)

    local RED=`tput setaf 1`
    local GREEN=`tput setaf 2`
    local RESET=`tput sgr0`

    local color;

    if [[ $diff_t -ge 200 ]]; then 
        color=$RED
    else
        color=$GREEN
    fi

    echo "Bash loaded in ${color}$diff_t ms${RESET}"
} && __show_elapsed_time && unset -f __show_elapsed_time
